; Naming conventions:
; variableValue
; CONSTANT_VALUE
; MainRoutineAndLables
; sub_routine

	listing off

	include "Constants.asm"
	include "Variables.asm"
	include "Macros.asm"

	listing purecode ; We sure want the listing file, but only the final code in expanded macros

; These switches enable the entire purpose of this driver and disabling them likely makes the playback similar to "traditional" DAC drivers
smoothPlayback:	equ TRUE	; Put it to FALSE to prevent 68k output during buffer load
accurateSpeed:	equ TRUE	; Put it to FALSE to ignore 68k sample increment calculation
; I often use this switch to test how an ideal and perfect playback would sound, and it's pretty close compared to both 68k and Z80
pureAudio:		equ FALSE	; Put it to TRUE to make only the 68k output DAC samples by defying the whole puropose of this audio driver
hardwareEarrape:	equ TRUE	; Put this to TRUE to test the true power of the YM2612's DAC output (SW: EXTREMELY LOUD AUDIO)

ROM_Start

	org 0

; ================================================================
; 68000 vectors (with its error code in square brackets, AAAAAAxx)
; ================================================================

		dc.l M68K.STACK			; Initial stack pointer value (SP value)
		dc.l EntryPoint			; Start of program (PC value)
		dc.l BusError			; Bus error							[1]
		dc.l AddressError		; Address error						[2]
		dc.l IllegalInstruction	; Illegal instruction				[3]
		dc.l DivisionByZero		; Division by zero					[4]
		dc.l CHKException		; CHK exception						[5]
		dc.l TRAPVException		; TRAPV exception					[6]
		dc.l PrivilegeViolation	; Privilege violation				[7]
		dc.l TRACEException		; TRACE exception					[8]
		dc.l LineAEmulator		; Line-A emulator					[9]
		dc.l LineFEmulator		; Line-F emulator					[10]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l SpuriousException	; Spurious exception				[11]
		dc.l InterruptRequest	; IRQ level 1						[12]
		dc.l InterruptRequest	; IRQ level 2						[12]
		dc.l InterruptRequest	; IRQ level 3 						[12]
		dc.l VDP_HBlank			; IRQ level 4 (horizontal retrace)
		dc.l InterruptRequest	; IRQ level 5						[12]
		dc.l VDP_VBlank			; IRQ level 6 (vertical retrace)
		dc.l InterruptRequest	; IRQ level 7						[12]
		dc.l TRAPException		; TRAP #00 exception				[13]
		dc.l TRAPException		; TRAP #01 exception				[13]
		dc.l TRAPException		; TRAP #02 exception				[13]
		dc.l TRAPException		; TRAP #03 exception				[13]
		dc.l TRAPException		; TRAP #04 exception				[13]
		dc.l TRAPException		; TRAP #05 exception				[13]
		dc.l TRAPException		; TRAP #06 exception				[13]
		dc.l TRAPException		; TRAP #07 exception				[13]
		dc.l TRAPException		; TRAP #08 exception				[13]
		dc.l TRAPException		; TRAP #09 exception				[13]
		dc.l TRAPException		; TRAP #10 exception				[13]
		dc.l TRAPException		; TRAP #11 exception				[13]
		dc.l TRAPException		; TRAP #12 exception				[13]
		dc.l TRAPException		; TRAP #13 exception				[13]
		dc.l TRAPException		; TRAP #14 exception				[13]
		dc.l TRAPException		; TRAP #15 exception				[13]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]
		dc.l UnknownError		; Unused (reserved)					[14]

; ===================================================================
; Mega Drive ROM header (reference: https://plutiedev.com/rom-header)
; ===================================================================

		dc.b "SEGA MEGA DRIVE "								; System type - 16 bytes
		dc.b "(C)BRO0 2024.OCT"								; Copyright, release year and month (e.g. "(C)SEGA 1991.APR") - 16 bytes
		dc.b "Codename FrankPCM: a high-tech audio driver"	; Domestic name - 48 bytes
		dc.b "     "										; Padding
		dc.b "Codename FrankPCM: a high-tech audio driver"	; Overseas name - 48 bytes
		dc.b "     "										; Padding
		dc.b "GM-12345678-00"								; Serial number ("xx-yyyyyyyy-zz") - 14 bytes
		dc.w $0000											; Where this ROM gets patched with a 16-bit checksum - 2 bytes
		dc.b "J               "								; Device support (e.g. "J" for 3-button controller) - 16 bytes
		dc.l ROM_Start										; Start address of ROM - 4 bytes
		dc.l ROM_End										; End address of ROM - 4 bytes
		dc.l $FF0000										; Start address of WRAM - 4 bytes
		dc.l $FFFFFF 										; End address of WRAM - 4 bytes
		dc.b "                                                                " ; padding for reserved space - 64 bytes
		dc.b "JUE"											; Region support - 16 bytes
		dc.b "             "								; padding for reserved space (you can put a comment if you want!) - 13 bytes

; ========================
; Error handler jump table
; ========================

BusError:
	move.l	#$AAAAAAA1,d7
	stop #$2700 ; some emulators might not recognize this instruction

AddressError:
	move.l	#$AAAAAAA2,d7
	stop #$2700

IllegalInstruction:
	move.l	#$AAAAAAA3,d7
	stop #$2700

DivisionByZero:
	move.l	#$AAAAAAA4,d7
	stop #$2700

CHKException:
	move.l	#$AAAAAAA5,d7
	stop #$2700

TRAPVException:
	move.l	#$AAAAAAA6,d7
	stop #$2700

PrivilegeViolation:
	move.l	#$AAAAAAA7,d7
	stop #$2700

TRACEException:
	move.l	#$AAAAAAA8,d7
	stop #$2700

LineAEmulator:
	move.l	#$AAAAAAA9,d7
	stop #$2700

LineFEmulator:
	move.l	#$AAAAAA10,d7
	stop #$2700

SpuriousException:
	move.l	#$AAAAAA11,d7
	stop #$2700

InterruptRequest:
	move.l	#$AAAAAA12,d7
	stop #$2700

TRAPException:
	move.l	#$AAAAAA13,d7
	stop #$2700

UnknownError:
	move.l	#$AAAAAA14,d7
	stop #$2700

; ==========================

; A2: live samples, A0: Z80 samples for later
; 240 68k cycles for every ~32 kHz sample

VDP_VBlank:
	; DPLC loading queues
; --- Variable cycles ---
	stopZ80								; Initiate Z80 stop. 20
	lea	YM2612_68K.DATA0,a3				; 8
	lea	playedSamples+1|Z80_CTRL.WRAM,a4	; 8
	lea Z80_CTRL.BUSREQ,a5			; 8
	move.l	(sampleIndex),a2		; 16
	moveq	#0,d0					; 4
	waitZ80	d0,a5					; 12 (at best)
	; --- 76 cycles in total ---
	move.w	(a4),d0		; Get high byte of playedSamples. 8
	move.b	-(a4),d0	; Get lower byte of playedSamples. 8
	adda.l	d0,a2		; 8

	if smoothPlayback
		move.b	(a2)+,(a3)	; Output sample. 12
	elseif accurateSpeed
		addq.l	#1,a2
		nop
	endif

; --- Cycle count restarts ---

	movea.l	a2,a0	; 4

	if accurateSpeed
		addaq	(BUFFER_ITERATIONS*3)+2,a0	; Sample index after 68k routine execution (A2 at the end, basically). 8
	endif

	move.l	a0,d2	; D2 is now the updated sample index. 4

	lea	SampleBuffer|Z80_CTRL.WRAM,a1	; 8
; --- 24 cycles in total ---
	btst	#0,d2					; Is the sample index even? 6
	beq.s	$$skip_alignment		; If yes, skip the alignment. 10
	move.b	(a0)+,(a1)				; If not, the 68k will crash, so we avoid it. 12
	addq.l	#2,a1					; 8
	move.l	a0,d2	; D2 is now the updated sample index. 4
$$skip_alignment:
	nop				; 4
	nop				; 4
	nop				; 4
	move.l	#ROM_End,d0			; 12
	sub.l	d2,d0				; Is the audio about to end (ends on Z80 buffer)? 8
; --- 84 cycles in total ---
	bpl.s	$$skip_tracking		; 10 cycles on branch, 8 cycles no branch
	; Z80 playback with sample tracking routine
	move.b	#Init_EndSound,(Z80Init.routineAddress+2)|Z80_CTRL.WRAM	; Little endian, 16 cycles
	lea	(Init_EndSound+2)|Z80_CTRL.WRAM,a4		; 8
	move.b	d0,(a4)							; 8
	lsr.w	#8,d0							; 22
	move.b	d0,-(a4)						; 8
	move.b	#1,shouldStop					; 16
	bra.s	$$continue						; 10
; --- 82 cycles in total ---
$$skip_tracking:
	; Normal Z80 playback routine
	lea	(Z80Init.routineAddress+1)|Z80_CTRL.WRAM,a4	; 8
	move.b	#Init_DacAndEffects&$FF,(a4)+		; 12
	move.b	#Init_DacAndEffects>>8,(a4)			; 12

$$continue:
; --- 126 cycles in total ---
	clr.b	(DisableDacInjection|Z80_CTRL.WRAM)		; 16

	loadSamples	; D0 and D1 break here

	if smoothPlayback
		move.b	(a2)+,(a3)	; Output sample, 12 cycles
	elseif accurateSpeed
		addq.l	#1,a2
		nop
	endif

; --- Cycle count restarts ---
	lea	(Z80EndRoutineAddress+1)|Z80_CTRL.WRAM,a0	; 8
	move.b	#Z80Init&$FF,(a0)+					; 12
	move.b	#Z80Init>>8,(a0)					; 12
	
	move.l	d2,(sampleIndex)					; 20

	moveq	#0,d0
	lea	FmControl,a0
	lea	CommandBuffer|Z80_CTRL.WRAM,a1
	move.b	(a0)+,d1
	move.b	d1,(Init_DacAndFm+1)
	lsr.b	#2,d1
	move.l	d1,d2

$$load_fm_ctrl:
	move.l	(a0)+,d0
	movep.l	d0,(a1)+
	dbf d1,$$load_fm_ctrl

	lea	(CommandBuffer+1)|Z80_CTRL.WRAM,a1

$$load_fm_data:
	move.l	(a0)+,d0
	movep.l	d0,(a1)+
	dbf d2,$$load_fm_data

	startZ80 a5	; Restart Z80

	rte

; ==========================

; Horizontal interrupt
VDP_HBlank:
	rte

; ==========================

EntryPoint:
	;move.l	#"SEGA",(REG_TMSS)

; ============================
; VDP initialization and setup
; ============================

; VDP setup reference: https://plutiedev.com/vdp-setup

	lea VDP.CTRL,a0

	tst.w 	(a0) ; Testing the VDP control port safely resets it
	
; Register reference: https://plutiedev.com/vdp-registers

	move.l  #(VDP_REG.MODE1|%00000100)<<16|(VDP_REG.MODE2|%01110100),(a0)	; Mode register #1 and Mode register #2
	move.l  #(VDP_REG.MODE3|%00000000)<<16|(VDP_REG.MODE4|%10000001),(a0)	; Mode register #3 and Mode Register #4
    
; Planes reference: https://segaretro.org/Sega_Mega_Drive/Planes

 	move.l  #VDP_REG.PLANEA|(VDP_VRAM.PLANEA>>10)<<16|(VDP_REG.PLANEB|(VDP_VRAM.PLANEB>>13)),(a0)	; Plane A and Plane B address
	move.l  #VDP_REG.SPRITE|(VDP_VRAM.SPRITE>>9)<<16|(VDP_REG.WINDOW|(VDP_VRAM.WINDOW>>10)),(a0)	; Sprite and Window address
	move.w  #VDP_REG.HSCROLL|(VDP_VRAM.HSCROLL>>10),(a0)										; Horizontal scroll address
    
	move.l  #(VDP_REG.WINX|$00)<<16|(VDP_REG.WINY|$00),(a0)			; Window X split and Window Y split
	move.l  #(VDP_REG.SIZE|%00000001)<<16|(VDP_REG.BGCOL|$00),(a0)	; Tilemap size and Background color
	move.l  #(VDP_REG.INCR|$02)<<16|(VDP_REG.HRATE|$FF),(a0)			; Autoincrement and HBlank IRQ rate

	moveq 	#$40,d0
	move.b	d0,(JOY1.CTRL)
	move.b	d0,(JOY1.DATA)

; Start of ROM code

	lea Z80_CTRL.BUSREQ,a3
	lea Z80_CTRL.RESET,a2

	move.w	#$100,d2	; Assert, stop
	moveq	#0,d1		; Deassert, start

	assertZ80Reset d1,a2	; Assert reset
	stopZ80 d2,a3			; Request bus
	deassertZ80Reset d2,a2	; Release reset

; We can do more stuff while the Z80 is theoretically stopping
	lea Z80ROM_Start,a0
	lea Z80_CTRL.WRAM,a1
	move.l 	#Music,(sampleIndex)
	move.w	#(Z80ROM_End-Z80ROM_Start)-1,d0	; Mustn't go over $7F

$$copy_program:
	move.b	(a0)+,(a1)+
	dbf d0,$$copy_program

	lea playedSamples|Z80_CTRL.WRAM,a0
	clr.b	(a0)+
	clr.b	(a0)
	clr.b	(shouldStop)

	assertZ80Reset d2,a2	; Assert reset

	moveq	#20,d0
    dbf	d0,*	; Wait for the YM2612

	deassertZ80Reset d2,a2	; Release reset

	if pureAudio
		loopTest 53
	endif

	startZ80 d1,a3			; Release bus

$$read_joypad
	lea	JOY1.DATA,a0
	move.b 	#$40,(a0)	; write $40 to request controller state
	nop	; wait for the bus to get the controller state
	nop
	nop
	nop
	move.b	(a0),d0	; put control state somewhere
	btst 	#JOY.C,d0
	beq.w	$$play_sample

$$halt_cpu:
	tst.b	(shouldStop)
	bne.s	$$disable_cpu
	stop	#$2500
	bra.s	$$read_joypad
$$disable_cpu:
	stop	#$2700
$$play_sample:
	move.l	#Music,(sampleIndex)
	bra.s	$$halt_cpu

	include "Driver.z80"

Music
	;binclude "continuity_test.bin" ; Test with increasing bytes to make sure no samples get skipped
	;binclude "24. Time Rift Shift ~ Vs. Metal Sonic.raw" ; Great music right here
	;binclude "Don't Stand So Close To Me.raw" ; Another banger
	;binclude "Spirits In The Material World.raw" ; This is a good one
	;binclude "Every Little Thing She Does Is Magic.raw" ; Another nice one
	;binclude "Ki.raw" ; minceraft
	;binclude "Droopy likes your face.raw" ; Underrated
	binclude "Chris.raw" ; Chris
	;binclude "Magnetic Circuit.raw" ; Notch what are you doing
	;binclude "music.pcm" ; Let's not talk about this
	;binclude "My Summary.raw"

	binclude "Minecraft Earrape.raw"

FmControl
	dc.b	8
	dc.b	YM2612ctrl_ALandFB(CH1_4)
	dc.b	YM2612ctrl_ARandRS(CH1_4,OP1)
	dc.b	YM2612ctrl_DRandAM(CH1_4,OP1)
	dc.b	YM2612ctrl_RRandSL(CH1_4,OP1)
	dc.b	YM2612ctrl_SR(CH1_4,OP1)
	dc.b	YM2612ctrl_MULandDT(CH1_4,OP1)
	dc.b	YM2612ctrl_TL(CH1_4,OP1)
	dc.b	YM2612ctrl_FR(CH1_4)

FmData
	dc.b	YM2612data_ALGandFB(0,4)
	dc.b	YM2612data_ARandRS(31,0)
	dc.b	YM2612data_DRandAM(8,0)
	dc.b	YM2612data_RRandSL(3,15)
	dc.b	YM2612data_SR(0)
	dc.b	YM2612data_MULandDT(5,2)
	dc.b	YM2612data_TL(42)
	dc.w	YM2612data_FR(4,644)

ROM_End