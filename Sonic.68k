; Naming conventions:
; variableValue
; CONSTANT_VALUE
; MainRoutineAndLables
; sub_routine
	
	cpu 68000
	
	supmode on ; We don't need warnings about privileged instructions

	include "Variables.asm"
	include "Constants.asm"
	include "Macros.asm"

	listing purecode ; We sure want the listing file, but only the final code in expanded macros

	org 0

RomStart ; Vectors
		dc.l SYS_STACK			; Initial stack pointer value (SP value)
		dc.l EntryPoint			; Start of program (PC value)
		dc.l BusError			; Bus error
		dc.l AddressError		; Address error
		dc.l IllegalInstruction	; Illegal instruction
		dc.l DivisionByZero		; Division by zero
		dc.l CHKException		; CHK exception
		dc.l TRAPVException		; TRAPV exception
		dc.l PrivilegeViolation	; Privilege violation
		dc.l TRACEException		; TRACE exception
		dc.l LineAEmulator		; Line-A emulator
		dc.l LineFEmulator		; Line-F emulator
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l SpuriousException	; Spurious exception
		dc.l GenericError		; IRQ level 1
		dc.l GenericError		; IRQ level 2
		dc.l GenericError		; IRQ level 3 
		dc.l GenericError		; IRQ level 4 (horizontal retrace interrupt)
		dc.l GenericError		; IRQ level 5
		dc.l VDP_VBlank			; IRQ level 6 (vertical retrace interrupt)
		dc.l GenericError		; IRQ level 7
		dc.l GenericError		; TRAP #00 exception
		dc.l GenericError		; TRAP #01 exception
		dc.l GenericError		; TRAP #02 exception
		dc.l GenericError		; TRAP #03 exception
		dc.l GenericError		; TRAP #04 exception
		dc.l GenericError		; TRAP #05 exception
		dc.l GenericError		; TRAP #06 exception
		dc.l GenericError		; TRAP #07 exception
		dc.l GenericError		; TRAP #08 exception
		dc.l GenericError		; TRAP #09 exception
		dc.l GenericError		; TRAP #10 exception
		dc.l GenericError		; TRAP #11 exception
		dc.l GenericError		; TRAP #12 exception
		dc.l GenericError		; TRAP #13 exception
		dc.l GenericError		; TRAP #14 exception
		dc.l GenericError		; TRAP #15 exception
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)
		dc.l GenericError		; Unused (reserved)

; ROM header
		dc.b "SEGA MEGA DRIVE",$20				; "$20" is padding
		dc.b "(C)BRO0 2024.OCT"					; Copyright(-ish), release year and month
		dc.b "Presentazione sistemi: 68k e x86"	; Domestic name
		dc.b "                "					; padding
		dc.b "Presentazione sistemi: 68k e x86"	; Overseas name
		dc.b "                "					; padding
		dc.b "AI-23456786-00"					; Serial number (I mashed the keyboard for this)
		dc.w $0000								; Empty checksum
		dc.b "J"								; Joypad type
		dc.b "               "					; padding
		dc.l RomStart							; Start address of ROM
		dc.l RomEnd								; End address of ROM
		dc.l $FF0000							; Start address of WRAM
		dc.l $FFFFFF 							; End address of WRAM
		dc.b "                                                                "
		dc.b "JU "								; Region support
		dc.b "             "					; padding for reserved space

; Error handler jump table

BusError:
	moveq	#1,d7
	stop #$2700

AddressError:
	moveq	#2,d7
	stop #$2700

IllegalInstruction:
	moveq	#3,d7
	stop #$2700

DivisionByZero:
	moveq	#4,d7
	stop #$2700

CHKException:
	moveq	#5,d7
	stop #$2700

TRAPVException:
	moveq	#6,d7
	stop #$2700

PrivilegeViolation:
	moveq	#7,d7
	stop #$2700

TRACEException:
	moveq	#8,d7
	stop #$2700

LineAEmulator:
	moveq	#9,d7
	stop #$2700

LineFEmulator:
	moveq	#10,d7
	stop #$2700

SpuriousException:
	moveq	#11,d7
	stop #$2700

GenericError:
	moveq	#12,d7
	stop #$2700

; A2: live samples, A0: Z80 samples for later

VDP_VBlank:
	; 240 68k cycles for every 32 kHz sample
	lea	YM2612_DATA|Z80_RAM,a3			; 8 cycles
	lea	(playedSamplesHigh|Z80_RAM),a4	; 8 cycles
	lea (Z80_BUSREQ),a5					; 8 cycles
	move.l	(sampleIndex),d2			; 12 cycles
	moveq	#0,d3						; 4 cycles
	move.w	#$100,d4					; 4 cycles
; --- 44 cycles in total ---
	moveq	#11,d0		; 4 cycles
$$z80_wait:
	dbf d0,$$z80_wait	; 124 cycles
; --- 172 cycles in total ---
	stopZ80 d4,a5		; Initiate Z80 stop, 8 cycles
	waitZ80 a5			; 26 cycles
; --- 206 cycles in total ---
	move.w	(a4)+,d3	; Get high byte of playedSamples, 8 cycles
	move.b	(a4),d3		; Get lower byte of playedSamples, 8 cycles
	add.l	d3,d2		; 8 cycles
	movea.l	d2,a2		; Sample index while executing 68k routine, 4 cycles
; --- 234 cycles in total ---
	move.b	(a2)+,(a3)	; Output sample, 12 cycles

; --- Cycle count restarts ---

	movea.l	d2,a0	; 4 cycles
	addaq	22+2,a0	; Sample index after 68k routine execution (A2 at the end, basically), 8 cycles
	move.l	a0,d2	; 4 cycles

	lea	SampleBuffer|Z80_RAM,a1			; 8 cycles
	lea	(Z80RoutineAddress)|Z80_RAM,a4	; 8 cycles
	move.l	#RomEnd,d4					; 12 cycles
	sub.l	d2,d4						; 8 cycles
	sub.w	d4,d3	; Is the audio about to end (ends on the buffer)? 4 cycles
	bhi.s	$$skip_tracking					; 10 cycles
	; Z80 playback with sample tracking routine
	move.b	#Loop_EndSoundInit&&$FF,(a4)+	; Little endian, 16 cycles
	move.b	#Loop_EndSoundInit>>8,(a4)		; 16 cycles
	move.b	d3,(Loop_EndSoundInit+1)		; 12 cycles
	lsr.w	#8,d3							; 22 cycles
	move.b	d3,(Loop_EndSoundInit+3)		; 16 cycles
	bra.s	$$continue						; 10 cycles

$$skip_tracking:
	; Normal Z80 playback
	move.b	#Loop&&$FF,(a4)+	; Little endian, 16 cycles
	move.b	#Loop>>8,(a4)		; 16 cycles

$$continue:
	btst	#0,d2				; Is the sample index even? 6 cycles
	beq.s	$$skip_alignment	; If yes, skip the alignment, 10 cycles
	move.b	(a0)+,(a1)			; If not, the 68k will crash, so we avoid it. 12 cycles
$$skip_alignment:

	move.l	#9,d0	; 12 cycles
$$timing_wait1:		; 104 cycles
	dbf d0,$$timing_wait1
; --- 166 cycles in total ---

	loadSamples

	move.b	(a2)+,(a3)

; --- Cycle count restarts ---
	move.b	#Wait68k.continue,((Wait68k+1)|Z80_RAM)	; 20 cycles
	move.l	d2,(sampleIndex)	; 20 cycles

	moveq	#8,d0 ; 20, theoretically, but less since the Z80 takes some time to wake up (need to make this more precise, though)
$$timing_wait2:
	dbf	d0,$$timing_wait2

	startZ80 a5	; Restart Z80

	; DPLC loading queues
	rte


EntryPoint:
	lea		VDP_CTRL,a0

; VDP register setup
	move.l  #(VDPREG_MODE1|%00000100)<<16|VDPREG_MODE2|%00100100,(a0)	; Mode register #1 and Mode register #2
	move.l  #(VDPREG_MODE3|%00000000)<<16|VDPREG_MODE4|%10000001,(a0)	; Mode register #3 and Mode register #4
	
	move.l  #(VDPREG_PLANEA|(PLANEA_ADDR>>10))<<16|VDPREG_PLANEB|(PLANEB_ADDR>>13),(a0)	; Plane A and Plane B address
	move.l  #(VDPREG_SPRITE|(SPRITE_ADDR>>9))<<16|VDPREG_WINDOW|(WINDOW_ADDR>>10),(a0)	; Sprite and Window address
    move.w  #VDPREG_HSCROLL|(HSCROLL_ADDR>>10),(a0)										; HScroll address
    
    move.l  #(VDPREG_SIZE|$00)<<16|VDPREG_WINX|$00,(a0)		; Tilemap size and Window X split
    move.l  #(VDPREG_WINY|$00)<<16|VDPREG_INCR|$00,(a0)		; Window Y split and Autoincrement
    move.l  #(VDPREG_BGCOL|$00)<<16|VDPREG_HRATE|$FF,(a0)	; Background color and HBlank IRQ rate

; Start of ROM code

	lea (Z80_BUSREQ),a3
	lea (Z80_RESET),a2

	move.w	#$100,d2	; Assert, stop
	moveq	#0,d1		; Deassert, start

	assertZ80Reset d1,a2	; Assert reset
	stopZ80 d2,a3			; Request bus
	deassertZ80Reset d2,a2	; Release reset

; We can do more stuff while the Z80 is theoretically stopping
	lea Z80RomStart,a0
	lea Z80_RAM,a1
	move.l 	#Music,(sampleIndex)
	move.w	#(Z80RomEnd-Z80RomStart)-1,d0	; Mustn't go over $7F

$$copy_program:
	move.b	(a0)+,(a1)+
	dbf d0,$$copy_program

	clr.b	(playedSamplesHigh|Z80_RAM)
	clr.b	(playedSamplesLow|Z80_RAM)

	assertZ80Reset d2,a2	; Assert reset

	moveq	#20,d0
$$wait:	; Wait for the YM2612
    dbf	d0,$$wait

	deassertZ80Reset d2,a2	; Release reset

	;loopTest1 53

	startZ80 d1,a3			; Release bus

HaltCPU:
	stop	#$2500	; Wait until next interrupt
	bra.s	HaltCPU

	include "Driver.z80"

Music:
	binclude "continuity_test.bin" ; Test with increasing bytes to make sure no samples get skipped
	;binclude "24. Time Rift Shift ~ Vs. Metal Sonic.raw" ; Great music right here
	;binclude "Don't Stand So Close To Me.raw" ; Another banger
	;binclude "music.pcm" ; Let's not talk about this
	;binclude "My Summary.raw"

RomEnd